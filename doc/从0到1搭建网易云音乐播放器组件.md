# 从0到1搭建网易云音乐播放器组件

> 本文将详细介绍如何在 Vue 3 项目中从零开始集成一个功能完整的网易云音乐播放器组件，包括后端 API 部署和前端组件开发。

## 目录

1. [项目简介](#项目简介)
2. [准备工作](#准备工作)
3. [后端部署：Vercel 部署网易云 API](#后端部署vercel-部署网易云-api)
4. [前端集成：音乐播放器组件](#前端集成音乐播放器组件)
5. [使用说明](#使用说明)
6. [常见问题](#常见问题)

---

## 项目简介

本项目使用的网易云音乐 API 是 [api-enhanced](https://github.com/neteasecloudmusicapienhanced/api-enhanced)，这是一个持续维护的网易云音乐第三方 Node.js API，支持丰富的音乐相关接口。

**API 特点：**
- 完全开源，支持自建服务
- 丰富的音乐接口（歌单、歌曲、歌词、搜索等）
- 支持 Docker 部署和一键部署到 Vercel

---

## 准备工作

在开始之前，请确保你已准备好以下环境：

| 工具 | 要求 | 说明 |
|------|------|------|
| Node.js | 14+ | 推荐 Node.js 16 或 18 |
| pnpm | 最新版本 | 或使用 npm/yarn |
| Git | 任意版本 | 用于克隆代码 |
| Vercel 账号 | 免费注册 | 用于部署 API |
| GitHub 账号 | 免费注册 | 用于 Fork 项目 |

---

## 后端部署：Vercel 部署网易云 API

### 步骤 1：Fork 项目

1. 打开 [api-enhanced 项目地址](https://github.com/neteasecloudmusicapienhanced/api-enhanced)
2. 点击右上角的 **Fork** 按钮，将项目复制到你的 GitHub 仓库

### 步骤 2：部署到 Vercel

1. 登录 [Vercel 控制台](https://vercel.com)
2. 点击 **Add New** → **Project**
3. 在 **Import Git Repository** 中搜索并选择你 Fork 的 `api-enhanced` 项目
4. 配置部署设置：
   - Framework Preset: **Express**（重要！）
   - Root Directory: 默认即可
5. 在 **Environment Variables** 中添加环境变量（可选）：
   ```
   PORT=9000
   ```
6. 点击 **Deploy** 等待部署完成

### 步骤 3：验证部署

部署完成后，Vercel 会分配一个域名，例如：`https://api-enhanced-xxx.vercel.app`

访问以下地址验证 API 是否正常：

```
https://你的域名/playlist/detail?id=12433389973
```

如果返回 JSON 数据，说明部署成功！

### 步骤 4：配置跨域支持（可选）

如果需要在前端直接调用 API，可能需要配置跨域。可以在 Vercel 的 `vercel.json` 中添加配置：

```json
{
  "rewrites": [
    {
      "source": "/(.*)",
      "destination": "/api/server.js"
    }
  ],
  "headers": [
    {
      "source": "/api/(.*)",
      "headers": [
        {
          "key": "Access-Control-Allow-Origin",
          "value": "*"
        }
      ]
    }
  ]
}
```

> **注意**：由于 Vercel Serverless Functions 的限制，某些 API 可能需要使用第三方代理。本项目已内置代理支持。

---

## 前端集成：音乐播放器组件

### 项目结构

```
src/
├── apis/
│   └── music.ts              # 网易云音乐 API 服务
├── components/
│   └── MusicPlayer/
│       ├── index.vue         # 主入口组件
│       ├── components/
│       │   ├── MusicFloatingBall.vue    # 悬浮球组件
│       │   ├── MusicPlayerPanel.vue     # 播放器面板
│       │   └── MusicPlayerMini.vue      # 迷你播放器（可选）
│       └── icons/            # SVG 图标
└── store/
    └── modules/
        └── music.ts          # Pinia 状态管理
```

### 步骤 1：创建 API 服务

创建 `src/apis/music.ts`：

```typescript
/**
 * 网易云音乐 API 服务
 * 使用 Vercel 部署的第三方代理服务
 */

const PROXY_URL = import.meta.env.VITE_APP_MUSIC_PROXY_URL

// 免费第三方代理API (使用 Vercel 部署的版本)
const FREE_PROXY_BASE = PROXY_URL || 'https://你的vercel域名.vercel.app'

// API基础地址
const API_BASE = `${FREE_PROXY_BASE}/api/music`

// 网易云API路径
const NCM_API = {
  playlistDetail: '/playlist/detail',
  songDetail: '/song/detail',
  songUrl: '/song/url',
  lyric: '/lyric',
  search: '/search',
}

// 歌单ID (替换为你自己的歌单)
export const PLAYLIST_ID = 12433389973

// 缓存配置
const CACHE_DURATION = 5 * 60 * 1000 // 5分钟

// 简单请求封装
async function request<T>(url: string, params: Record<string, any> = {}): Promise<T> {
  const apiUrl = API_BASE + url
  const queryString = new URLSearchParams(params).toString()
  const fullUrl = queryString ? `${apiUrl}?${queryString}` : apiUrl

  try {
    const response = await fetch(fullUrl)
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`)
    }
    return response.json()
  } catch (error) {
    console.error('Music API Error:', error)
    throw error
  }
}

// 歌曲类型
export interface Song {
  id: number
  name: string
  artists: Artist[]
  album: Album
  duration: number
  url?: string
  picUrl?: string
}

export interface Artist {
  id: number
  name: string
}

export interface Album {
  id: number
  name: string
  picUrl: string
}

// 从网易云数据结构转换为统一格式
function transformSong(songs: any[]): Song[] {
  if (!songs) return []
  return songs.map((item: any) => ({
    id: item.id,
    name: item.name,
    artists: item.ar || item.artists || [],
    album: {
      id: item.al?.id || item.album?.id,
      name: item.al?.name || item.album?.name || '未知专辑',
      picUrl: item.al?.picUrl || item.album?.picUrl || '',
    },
    duration: item.dt || item.duration || 0,
  }))
}

/**
 * 获取歌单详情
 */
export async function getPlaylistDetail(id: number | string) {
  const data = await request<any>(NCM_API.playlistDetail, { id: id.toString() })
  if (data.code !== 200) throw new Error('获取歌单详情失败')
  return {
    playlist: data.playlist,
    songs: transformSong(data.playlist.tracks),
  }
}

/**
 * 获取歌曲播放URL
 */
export async function getSongUrl(id: number | string): Promise<string> {
  const data = await request<any>(NCM_API.songUrl, { id: id.toString() })
  if (data.code !== 200) throw new Error('获取歌曲URL失败')
  const songData = data.data?.[0]
  if (songData?.url) return songData.url
  throw new Error('歌曲无法播放（VIP限制）')
}

/**
 * 获取歌词
 */
export async function getLyric(id: number | string): Promise<string> {
  const data = await request<any>(NCM_API.lyric, { id: id.toString() })
  if (data.code !== 200) throw new Error('获取歌词失败')
  return data.lrc?.lyric || ''
}

// 本地缓存管理
const cache = new Map<string, { data: any; time: number }>()

function getCache<T>(key: string): T | null {
  const item = cache.get(key)
  if (item && Date.now() - item.time < CACHE_DURATION) return item.data
  cache.delete(key)
  return null
}

function setCache(key: string, data: any): void {
  cache.set(key, { data, time: Date.now() })
}

/**
 * 获取并缓存歌单详情
 */
export async function getCachedPlaylistDetail(id: number | string) {
  const cacheKey = `playlist_${id}`
  const cached = getCache<any>(cacheKey)
  if (cached) return cached
  const data = await getPlaylistDetail(id)
  setCache(cacheKey, data)
  return data
}
```

### 步骤 2：创建 Pinia Store

创建 `src/store/modules/music.ts`：

```typescript
import { defineStore } from 'pinia'
import { ref, computed, watch } from 'vue'
import {
  getCachedPlaylistDetail,
  getSongUrl,
  getLyric,
  type Song,
} from '@/apis/music'

// 歌词行类型
interface LyricLine {
  time: number
  text: string
}

// 播放器状态类型
interface MusicState {
  isPlaying: boolean
  isExpanded: boolean
  isMuted: boolean
  volume: number
  currentTime: number
  duration: number
  playMode: 'order' | 'random' | 'single'
  currentSong: Song | null
  playlist: Song[]
  currentIndex: number
  currentLyric: string
  lyricLines: LyricLine[]
  currentLyricIndex: number
  isLoading: boolean
  error: string | null
}

// 解析歌词
function parseLyric(lrc: string): LyricLine[] {
  const lines: LyricLine[] = []
  const regex = /\[(\d{2}):(\d{2})\.(\d{2,3})\](.*)/g
  let match
  while ((match = regex.exec(lrc)) !== null) {
    const min = parseInt(match[1])
    const sec = parseInt(match[2])
    const ms = parseInt(match[3])
    const time = min * 60 + sec + ms / 1000
    const text = match[4].trim()
    if (text) lines.push({ time, text })
  }
  lines.sort((a, b) => a.time - b.time)
  return lines
}

// 随机打乱播放列表
function shuffleArray<T>(arr: T[]): T[] {
  const result = [...arr]
  for (let i = result.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1))
    ;[result[i], result[j]] = [result[j], result[i]]
  }
  return result
}

export const useMusicStore = defineStore('music', () => {
  // 状态定义
  const isPlaying = ref(false)
  const isExpanded = ref(false)
  const isMuted = ref(false)
  const volume = ref(0.8)
  const currentTime = ref(0)
  const duration = ref(0)
  const playMode = ref<'order' | 'random' | 'single'>('order')
  const currentSong = ref<Song | null>(null)
  const playlist = ref<Song[]>([])
  const currentIndex = ref(-1)
  const currentLyric = ref('')
  const lyricLines = ref<LyricLine[]>([])
  const currentLyricIndex = ref(-1)
  const isLoading = ref(false)
  const error = ref<string | null>(null)
  const vipSongIds = ref<Set<number>>(new Set())

  // 音频元素
  let audioElement: HTMLAudioElement | null = null

  // 计算属性
  const hasPlaylist = computed(() => playlist.value.length > 0)
  const progress = computed(() => {
    if (duration.value === 0) return 0
    return (currentTime.value / duration.value) * 100
  })
  const playModeText = computed(() => {
    const texts: Record<string, string> = { order: '顺序播放', random: '随机播放', single: '单曲循环' }
    return texts[playMode.value]
  })

  // 过滤后的播放列表（不显示VIP歌曲）
  const filteredPlaylist = computed(() => {
    return playlist.value.filter(song => !vipSongIds.value.has(song.id))
  })

  // 初始化音频元素
  function initAudio() {
    if (!audioElement) {
      audioElement = new Audio()
      audioElement.volume = volume.value

      audioElement.addEventListener('timeupdate', () => {
        if (!audioElement) return
        currentTime.value = audioElement.currentTime
        updateLyricIndex()
      })
      audioElement.addEventListener('loadedmetadata', () => {
        if (!audioElement) return
        duration.value = audioElement.duration
      })
      audioElement.addEventListener('ended', onEnded)
      audioElement.addEventListener('play', () => { isPlaying.value = true })
      audioElement.addEventListener('pause', () => { isPlaying.value = false })
      audioElement.addEventListener('error', onError)
      audioElement.preload = 'metadata'
    }
    return audioElement
  }

  // 更新歌词索引
  function updateLyricIndex() {
    const time = currentTime.value
    let index = -1
    for (let i = lyricLines.value.length - 1; i >= 0; i--) {
      if (lyricLines.value[i].time <= time) {
        index = i
        break
      }
    }
    currentLyricIndex.value = index
  }

  // 播放结束
  function onEnded() {
    if (playMode.value === 'single') {
      audioElement && (audioElement.currentTime = 0)
      audioElement?.play()
    } else {
      playNext()
    }
  }

  // 播放错误
  function onError(e: Event) {
    console.error('Audio error:', e)
    error.value = '播放失败，请尝试切换歌曲'
    isPlaying.value = false
  }

  // 加载歌单
  async function loadPlaylist(playlistId: string | number) {
    isLoading.value = true
    error.value = null

    try {
      const data = await getCachedPlaylistDetail(playlistId)
      playlist.value = data.songs

      if (playMode.value === 'random') {
        playlist.value = shuffleArray(playlist.value)
      }

      // 自动播放第一首非VIP歌曲
      if (playlist.value.length > 0) {
        await playFirstAvailableSong()
      }
    } catch (e: any) {
      error.value = e.message || '加载歌单失败'
    } finally {
      isLoading.value = false
    }
  }

  // 播放第一首可用歌曲
  async function playFirstAvailableSong() {
    if (playlist.value.length === 0) return
    const firstAvailable = playlist.value.find(song => !vipSongIds.value.has(song.id))
    if (firstAvailable) {
      const index = playlist.value.findIndex(s => s.id === firstAvailable.id)
      await playSong(firstAvailable, index)
    }
  }

  // 播放歌曲
  async function playSong(song: Song, index: number) {
    currentSong.value = song
    currentIndex.value = index
    isLoading.value = true
    error.value = null

    try {
      const audio = initAudio()
      const url = await getSongUrl(song.id)

      // 检测VIP歌曲
      if (!url || url === '' || !url.startsWith('http')) {
        vipSongIds.value.add(song.id)
        isLoading.value = false
        playNextWithSkipVip(index)
        return
      }

      audio.src = url
      audio.play()

      // 加载歌词
      try {
        const lrc = await getLyric(song.id)
        currentLyric.value = lrc
        lyricLines.value = parseLyric(lrc)
      } catch {
        currentLyric.value = ''
        lyricLines.value = []
      }
    } catch (e: any) {
      error.value = e.message || '播放失败'
      isPlaying.value = false
    } finally {
      isLoading.value = false
    }
  }

  // 跳过VIP歌曲播放下一首
  function playNextWithSkipVip(currentIdx: number) {
    if (!hasPlaylist.value) return
    const filteredList = filteredPlaylist.value
    if (filteredList.length === 0) {
      error.value = '没有可播放的歌曲'
      return
    }
    const currentSongId = playlist.value[currentIdx]?.id
    const currentFilterIndex = filteredList.findIndex(s => s.id === currentSongId)
    let nextFilterIndex = currentFilterIndex + 1
    if (nextFilterIndex >= filteredList.length) nextFilterIndex = 0
    const nextSong = filteredList[nextFilterIndex]
    const nextOriginalIndex = playlist.value.findIndex(s => s.id === nextSong.id)
    if (nextOriginalIndex >= 0) playSong(nextSong, nextOriginalIndex)
  }

  // 播放/暂停
  function togglePlay() {
    if (!audioElement) return
    if (isPlaying.value) audioElement.pause()
    else audioElement.play()
  }

  // 上一首/下一首
  function playPrev() {
    if (!hasPlaylist.value) return
    let prevIndex = currentIndex.value - 1
    if (prevIndex < 0) prevIndex = playlist.value.length - 1
    playSong(playlist.value[prevIndex], prevIndex)
  }

  function playNext() {
    if (!hasPlaylist.value) return
    let nextIndex = currentIndex.value + 1
    if (nextIndex >= playlist.value.length) nextIndex = 0
    playSong(playlist.value[nextIndex], nextIndex)
  }

  // 跳转进度
  function seek(time: number) {
    if (!audioElement) return
    audioElement.currentTime = time
    currentTime.value = time
  }

  function seekPercent(percent: number) {
    const time = (percent / 100) * duration.value
    seek(time)
  }

  // 音量控制
  function setVolume(val: number) {
    volume.value = Math.max(0, Math.min(1, val))
    if (audioElement) audioElement.volume = volume.value
    if (val > 0 && isMuted.value) isMuted.value = false
  }

  function toggleMute() {
    isMuted.value = !isMuted.value
    if (audioElement) audioElement.muted = isMuted.value
  }

  // 切换播放模式
  function togglePlayMode() {
    const modes: Array<'order' | 'random' | 'single'> = ['order', 'random', 'single']
    const currentIdx = modes.indexOf(playMode.value)
    playMode.value = modes[(currentIdx + 1) % modes.length]
    if (playMode.value === 'random') {
      playlist.value = shuffleArray(playlist.value)
    }
  }

  // 播放指定索引
  function playByIndex(index: number) {
    if (index >= 0 && index < playlist.value.length) {
      playSong(playlist.value[index], index)
    }
  }

  // 展开/收起
  function expand() { isExpanded.value = true }
  function collapse() { isExpanded.value = false }
  function toggleExpand() { isExpanded.value = !isExpanded.value }

  return {
    isPlaying, isExpanded, isMuted, volume, currentTime, duration, playMode,
    currentSong, playlist, filteredPlaylist, currentIndex,
    currentLyric, lyricLines, currentLyricIndex, isLoading, error,
    hasPlaylist, progress, playModeText,
    loadPlaylist, playSong, togglePlay, playPrev, playNext, playNextWithSkipVip,
    seek, seekPercent, setVolume, toggleMute, togglePlayMode, playByIndex,
    expand, collapse, toggleExpand,
  }
})
```

### 步骤 3：创建悬浮球组件

创建 `src/components/MusicPlayer/components/MusicFloatingBall.vue`：

```vue
<template>
  <Teleport to="body">
    <Transition name="float-bounce">
      <div
        v-if="musicStore.hasPlaylist || musicStore.isExpanded"
        class="music-floating-ball"
        :style="ballStyle"
        @click.stop="handleClick"
        @mouseenter="isHovered = true"
        @mouseleave="isHovered = false"
      >
        <!-- 封面图片 -->
        <div class="ball-cover" :class="{ 'is-playing': musicStore.isPlaying }">
          <img
            v-if="currentCover"
            :src="currentCover"
            alt="cover"
            @load="onImageLoad"
            @error="onImageError"
          />
          <div v-else class="ball-placeholder">
            <svg-icon name="music" class="music-icon" />
          </div>
        </div>

        <!-- 播放状态指示器 -->
        <div v-if="musicStore.isPlaying" class="playing-indicator">
          <span class="bar" :style="{ animationDelay: '0s' }"></span>
          <span class="bar" :style="{ animationDelay: '0.2s' }"></span>
          <span class="bar" :style="{ animationDelay: '0.4s' }"></span>
        </div>

        <!-- 悬浮提示 -->
        <Transition name="tooltip-fade">
          <div v-if="showTooltip && !musicStore.isExpanded" class="ball-tooltip">
            {{ musicStore.currentSong?.name || '未播放' }}
          </div>
        </Transition>
      </div>
    </Transition>
  </Teleport>
</template>

<script setup lang="ts">
import { ref, computed, watch, onMounted, onUnmounted } from 'vue'
import { useMusicStore } from '@/store/modules/music'
import SvgIcon from '@/components/SvgIcon/index.vue'

const musicStore = useMusicStore()
const isHovered = ref(false)
const showTooltip = ref(false)
const coverColors = ref<string>('linear-gradient(135deg, #5cbfef, #62c28a)')

const currentCover = computed(() => musicStore.currentSong?.album.picUrl)

const ballStyle = computed(() => ({
  background: coverColors.value,
  boxShadow: `0 4px 20px rgba(0, 0, 0, 0.3)`,
}))

function handleClick() {
  musicStore.toggleExpand()
}

// 颜色提取和渐变生成（省略具体实现，可参考完整代码）
async function onImageLoad() {
  if (currentCover.value) {
    // 提取封面颜色生成渐变
  }
}

function onImageError() {
  coverColors.value = 'linear-gradient(135deg, #5cbfef, #62c28a)'
}

watch(() => musicStore.currentSong?.album.picUrl, async (newCover) => {
  if (newCover) await onImageLoad()
})

onMounted(() => {
  setTimeout(() => { showTooltip.value = true }, 1000)
})
</script>

<style scoped lang="scss">
.music-floating-ball {
  position: fixed;
  bottom: 80px;
  left: 30px;
  width: 56px;
  height: 56px;
  border-radius: 50%;
  cursor: pointer;
  z-index: 9998;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: transform 0.3s ease;
  backdrop-filter: blur(10px);

  &:hover {
    transform: scale(1.1);
  }
}

.ball-cover {
  width: 48px;
  height: 48px;
  border-radius: 50%;
  overflow: hidden;

  img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  &.is-playing img {
    animation: rotate 10s linear infinite;
  }
}

@keyframes rotate {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}
</style>
```

### 步骤 4：创建播放器面板

创建 `src/components/MusicPlayer/components/MusicPlayerPanel.vue`：

这是完整的面板组件，包含：
- 毛玻璃风格 UI
- 歌词同步滚动
- 播放列表
- 进度条控制
- 音量控制

（完整代码较长，可参考项目源文件）

### 步骤 5：创建主入口组件

创建 `src/components/MusicPlayer/index.vue`：

```vue
<template>
  <div class="music-player">
    <MusicFloatingBall />
    <MusicPlayerPanel />
  </div>
</template>

<script setup lang="ts">
import MusicFloatingBall from './components/MusicFloatingBall.vue'
import MusicPlayerPanel from './components/MusicPlayerPanel.vue'
</script>
```

### 步骤 6：在 App.vue 中引入

```vue
<template>
  <div id="app">
    <!-- 其他组件 -->
    <MusicPlayer />
  </div>
</template>

<script setup lang="ts">
import MusicPlayer from '@/components/MusicPlayer/index.vue'
</script>
```

---

## 使用说明

### 1. 更换歌单

在 `src/apis/music.ts` 中修改：

```typescript
export const PLAYLIST_ID = 你的歌单ID
```

### 2. 配置自定义 API 地址

在 `.env` 文件中：

```env
VITE_APP_MUSIC_PROXY_URL=https://你的vercel域名.vercel.app
```

### 3. 功能特性

| 功能 | 说明 |
|------|------|
| 播放/暂停 | 点击悬浮球或面板控制按钮 |
| 上一首/下一首 | 点击对应按钮或键盘方向键 |
| 进度拖拽 | 点击进度条跳转 |
| 音量调节 | 底部音量滑块 |
| 播放模式 | 顺序/随机/单曲循环 |
| 歌词同步 | 自动滚动高亮当前歌词 |
| VIP歌曲 | 自动跳过，不显示 |

---

## 常见问题

### Q1: VIP 歌曲无法播放？

这是网易云音乐的限制。组件已自动跳过 VIP 歌曲。

### Q2: 歌词显示不全？

歌词需要歌曲本身包含 LRC 格式的歌词数据。

### Q3: API 请求报错？

1. 检查 Vercel 部署是否成功
2. 确认 API 域名可访问
3. 尝试清除浏览器缓存

### Q4: 跨域问题？

Vercel 部署的 API 默认支持跨域。如有问题，可使用第三方代理。

---

## 参考资料

- [网易云音乐 API Enhanced 项目](https://github.com/neteasecloudmusicapienhanced/api-enhanced)
- [Vercel 官方文档](https://vercel.com/docs)
- [Vue 3 官方文档](https://vuejs.org/)
- [Pinia 官方文档](https://pinia.vuejs.org/)

---

**感谢阅读！如有疑问，欢迎在项目 Issue 中讨论。**
